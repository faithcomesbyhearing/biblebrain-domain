// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const getFilesForBible = `-- name: GetFilesForBible :many
select REGEXP_SUBSTR(bfs.set_type_code, 'audio|video|text') as type,
bfc.bible_id, bfs.id, bf.file_name
from bible_files bf
join bible_fileset_connections bfc on bfc.hash_id = bf.hash_id
join bible_filesets bfs on bfs.hash_id = bf.hash_id
where bfc.bible_id = ?
order by bfs.asset_id, bfc.bible_id, bfs.id, bf.file_name
`

type GetFilesForBibleRow struct {
	Type     string `json:"type"`
	BibleID  string `json:"bible_id"`
	ID       string `json:"id"`
	FileName string `json:"file_name"`
}

func (q *Queries) GetFilesForBible(ctx context.Context, bibleID string) ([]GetFilesForBibleRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilesForBible, bibleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilesForBibleRow
	for rows.Next() {
		var i GetFilesForBibleRow
		if err := rows.Scan(
			&i.Type,
			&i.BibleID,
			&i.ID,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesForFileset = `-- name: GetFilesForFileset :many
select REGEXP_SUBSTR(bfs.set_type_code, 'audio|video|text') as type,
bfc.bible_id, bfs.id, bf.file_name
from bible_files bf
join bible_fileset_connections bfc on bfc.hash_id = bf.hash_id
join bible_filesets bfs on bfs.hash_id = bf.hash_id
where bfs.id = ?
order by bfs.asset_id, bfc.bible_id, bfs.id, bf.file_name
`

type GetFilesForFilesetRow struct {
	Type     string `json:"type"`
	BibleID  string `json:"bible_id"`
	ID       string `json:"id"`
	FileName string `json:"file_name"`
}

func (q *Queries) GetFilesForFileset(ctx context.Context, id string) ([]GetFilesForFilesetRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilesForFileset, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilesForFilesetRow
	for rows.Next() {
		var i GetFilesForFilesetRow
		if err := rows.Scan(
			&i.Type,
			&i.BibleID,
			&i.ID,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoragePrefixForFileset = `-- name: GetStoragePrefixForFileset :one

select CONCAT(REGEXP_SUBSTR(bfs.set_type_code, 'audio|video|text'), "/", bfc.bible_id, "/", bfs.id, "/")
from bible_fileset_connections bfc 
join bible_filesets bfs on bfs.hash_id = bfc.hash_id
where bfs.id =?
`

// queries.sql
func (q *Queries) GetStoragePrefixForFileset(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getStoragePrefixForFileset, id)
	var concat string
	err := row.Scan(&concat)
	return concat, err
}

const hlsStitchingDrillDown = `-- name: HlsStitchingDrillDown :many
select b.id as bible, bfs.id as fileset, bf.id as bible_file_id, bfsb.id as stream_bandwidth_id, bfsb.resolution_height, bfsb.file_name, bfst.id as stream_ts_id, bfsb.updated_at
from bibles b
join bible_fileset_connections bfc on bfc.bible_id = b.id
join bible_filesets bfs on bfs.hash_id = bfc.hash_id
join bible_files bf on bf.hash_id = bfs.hash_id
join bible_file_stream_bandwidths bfsb on bfsb.bible_file_id = bf.id
left join bible_file_stream_ts bfst on bfst.stream_bandwidth_id = bfsb.id
where b.id = ?
and bfst.id is null
and set_type_code like 'video%'
order by bfsb.resolution_height, bf.book_id, bf.chapter_start, bf.verse_start
`

type HlsStitchingDrillDownRow struct {
	Bible             string        `json:"bible"`
	Fileset           string        `json:"fileset"`
	BibleFileID       uint32        `json:"bible_file_id"`
	StreamBandwidthID uint32        `json:"stream_bandwidth_id"`
	ResolutionHeight  sql.NullInt32 `json:"resolution_height"`
	FileName          string        `json:"file_name"`
	StreamTsID        sql.NullInt32 `json:"stream_ts_id"`
	UpdatedAt         time.Time     `json:"updated_at"`
}

func (q *Queries) HlsStitchingDrillDown(ctx context.Context, id string) ([]HlsStitchingDrillDownRow, error) {
	rows, err := q.db.QueryContext(ctx, hlsStitchingDrillDown, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HlsStitchingDrillDownRow
	for rows.Next() {
		var i HlsStitchingDrillDownRow
		if err := rows.Scan(
			&i.Bible,
			&i.Fileset,
			&i.BibleFileID,
			&i.StreamBandwidthID,
			&i.ResolutionHeight,
			&i.FileName,
			&i.StreamTsID,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hlsStitchingSearch = `-- name: HlsStitchingSearch :many
select distinct b.id as bible
from bibles b
join bible_fileset_connections bfc on bfc.bible_id = b.id
join bible_filesets bfs on bfs.hash_id = bfc.hash_id
join bible_files bf on bf.hash_id = bfs.hash_id
left join bible_file_stream_bandwidths bfsb on bfsb.bible_file_id = bf.id
left join bible_file_stream_ts bfst on bfst.stream_bandwidth_id = bfsb.id
where bfs.archived is false
and set_type_code like 'video%'
and bfst.id is null 
order by b.id
`

func (q *Queries) HlsStitchingSearch(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, hlsStitchingSearch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var bible string
		if err := rows.Scan(&bible); err != nil {
			return nil, err
		}
		items = append(items, bible)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
