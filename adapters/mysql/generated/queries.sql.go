// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package sqlc

import (
	"context"
)

const getFilesForBible = `-- name: GetFilesForBible :many
select REGEXP_SUBSTR(bfs.set_type_code, 'audio|video|text') as type,
bfc.bible_id, bfs.id, bf.file_name
from bible_files bf
join bible_fileset_connections bfc on bfc.hash_id = bf.hash_id
join bible_filesets bfs on bfs.hash_id = bf.hash_id
where bfc.bible_id = ?
order by bfs.asset_id, bfc.bible_id, bfs.id, bf.file_name
`

type GetFilesForBibleRow struct {
	Type     string `json:"type"`
	BibleID  string `json:"bible_id"`
	ID       string `json:"id"`
	FileName string `json:"file_name"`
}

func (q *Queries) GetFilesForBible(ctx context.Context, bibleID string) ([]GetFilesForBibleRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilesForBible, bibleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilesForBibleRow
	for rows.Next() {
		var i GetFilesForBibleRow
		if err := rows.Scan(
			&i.Type,
			&i.BibleID,
			&i.ID,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesForFileset = `-- name: GetFilesForFileset :many
select REGEXP_SUBSTR(bfs.set_type_code, 'audio|video|text') as type,
bfc.bible_id, bfs.id, bf.file_name
from bible_files bf
join bible_fileset_connections bfc on bfc.hash_id = bf.hash_id
join bible_filesets bfs on bfs.hash_id = bf.hash_id
where bfs.id = ?
order by bfs.asset_id, bfc.bible_id, bfs.id, bf.file_name
`

type GetFilesForFilesetRow struct {
	Type     string `json:"type"`
	BibleID  string `json:"bible_id"`
	ID       string `json:"id"`
	FileName string `json:"file_name"`
}

func (q *Queries) GetFilesForFileset(ctx context.Context, id string) ([]GetFilesForFilesetRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilesForFileset, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilesForFilesetRow
	for rows.Next() {
		var i GetFilesForFilesetRow
		if err := rows.Scan(
			&i.Type,
			&i.BibleID,
			&i.ID,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoragePrefixForFileset = `-- name: GetStoragePrefixForFileset :one

select CONCAT(REGEXP_SUBSTR(bfs.set_type_code, 'audio|video|text'), "/", bfc.bible_id, "/", bfs.id, "/")
from bible_fileset_connections bfc 
join bible_filesets bfs on bfs.hash_id = bfc.hash_id
where bfs.id =?
`

// queries.sql
func (q *Queries) GetStoragePrefixForFileset(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getStoragePrefixForFileset, id)
	var concat string
	err := row.Scan(&concat)
	return concat, err
}
